import{a as Ct,E as Pt}from"./chunk.rappkit-core-D4oqLfFx.js";import{i as Rt,W as De,d as xt,e as qe,C as Ut,g as Tt}from"./chunk.rappkit-ui-CSaCLIY7.js";import"https://esm.sh/react@18.3.1";import"./chunk.rappkit-utils-DJqMpFvj.js";import"https://esm.sh/viem@2.26.2";import"./chunk.wc-libs-DepVwrWw.js";class ${constructor(e,n){this.scope=e,this.module=n}storeObject(e,n){this.setItem(e,JSON.stringify(n))}loadObject(e){const n=this.getItem(e);return n?JSON.parse(n):void 0}setItem(e,n){localStorage.setItem(this.scopedKey(e),n)}getItem(e){return localStorage.getItem(this.scopedKey(e))}removeItem(e){localStorage.removeItem(this.scopedKey(e))}clear(){const e=this.scopedKey(""),n=[];for(let s=0;s<localStorage.length;s++){const i=localStorage.key(s);typeof i=="string"&&i.startsWith(e)&&n.push(i)}n.forEach(s=>localStorage.removeItem(s))}scopedKey(e){return`-${this.scope}${this.module?`:${this.module}`:""}:${e}`}static clearAll(){new $("CBWSDK").clear(),new $("walletlink").clear()}}const N={rpc:{invalidInput:-32e3,resourceNotFound:-32001,resourceUnavailable:-32002,transactionRejected:-32003,methodNotSupported:-32004,limitExceeded:-32005,parse:-32700,invalidRequest:-32600,methodNotFound:-32601,invalidParams:-32602,internal:-32603},provider:{userRejectedRequest:4001,unauthorized:4100,unsupportedMethod:4200,disconnected:4900,chainDisconnected:4901,unsupportedChain:4902}},Se={"-32700":{standard:"JSON RPC 2.0",message:"Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."},"-32600":{standard:"JSON RPC 2.0",message:"The JSON sent is not a valid Request object."},"-32601":{standard:"JSON RPC 2.0",message:"The method does not exist / is not available."},"-32602":{standard:"JSON RPC 2.0",message:"Invalid method parameter(s)."},"-32603":{standard:"JSON RPC 2.0",message:"Internal JSON-RPC error."},"-32000":{standard:"EIP-1474",message:"Invalid input."},"-32001":{standard:"EIP-1474",message:"Resource not found."},"-32002":{standard:"EIP-1474",message:"Resource unavailable."},"-32003":{standard:"EIP-1474",message:"Transaction rejected."},"-32004":{standard:"EIP-1474",message:"Method not supported."},"-32005":{standard:"EIP-1474",message:"Request limit exceeded."},4001:{standard:"EIP-1193",message:"User rejected the request."},4100:{standard:"EIP-1193",message:"The requested account and/or method has not been authorized by the user."},4200:{standard:"EIP-1193",message:"The requested method is not supported by this Ethereum provider."},4900:{standard:"EIP-1193",message:"The provider is disconnected from all chains."},4901:{standard:"EIP-1193",message:"The provider is disconnected from the specified chain."},4902:{standard:"EIP-3085",message:"Unrecognized chain ID."}},ot="Unspecified error message.",Lt="Unspecified server error.";function Re(t,e=ot){if(t&&Number.isInteger(t)){const n=t.toString();if(ke(Se,n))return Se[n].message;if(ct(t))return Lt}return e}function Ot(t){if(!Number.isInteger(t))return!1;const e=t.toString();return!!(Se[e]||ct(t))}function Bt(t,{shouldIncludeStack:e=!1}={}){const n={};if(t&&typeof t=="object"&&!Array.isArray(t)&&ke(t,"code")&&Ot(t.code)){const s=t;n.code=s.code,s.message&&typeof s.message=="string"?(n.message=s.message,ke(s,"data")&&(n.data=s.data)):(n.message=Re(n.code),n.data={originalError:He(t)})}else n.code=N.rpc.internal,n.message=Ke(t,"message")?t.message:ot,n.data={originalError:He(t)};return e&&(n.stack=Ke(t,"stack")?t.stack:void 0),n}function ct(t){return t>=-32099&&t<=-32e3}function He(t){return t&&typeof t=="object"&&!Array.isArray(t)?Object.assign({},t):t}function ke(t,e){return Object.prototype.hasOwnProperty.call(t,e)}function Ke(t,e){return typeof t=="object"&&t!==null&&e in t&&typeof t[e]=="string"}const A={rpc:{parse:t=>M(N.rpc.parse,t),invalidRequest:t=>M(N.rpc.invalidRequest,t),invalidParams:t=>M(N.rpc.invalidParams,t),methodNotFound:t=>M(N.rpc.methodNotFound,t),internal:t=>M(N.rpc.internal,t),server:t=>{if(!t||typeof t!="object"||Array.isArray(t))throw new Error("Ethereum RPC Server errors must provide single object argument.");const{code:e}=t;if(!Number.isInteger(e)||e>-32005||e<-32099)throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');return M(e,t)},invalidInput:t=>M(N.rpc.invalidInput,t),resourceNotFound:t=>M(N.rpc.resourceNotFound,t),resourceUnavailable:t=>M(N.rpc.resourceUnavailable,t),transactionRejected:t=>M(N.rpc.transactionRejected,t),methodNotSupported:t=>M(N.rpc.methodNotSupported,t),limitExceeded:t=>M(N.rpc.limitExceeded,t)},provider:{userRejectedRequest:t=>se(N.provider.userRejectedRequest,t),unauthorized:t=>se(N.provider.unauthorized,t),unsupportedMethod:t=>se(N.provider.unsupportedMethod,t),disconnected:t=>se(N.provider.disconnected,t),chainDisconnected:t=>se(N.provider.chainDisconnected,t),unsupportedChain:t=>se(N.provider.unsupportedChain,t),custom:t=>{if(!t||typeof t!="object"||Array.isArray(t))throw new Error("Ethereum Provider custom errors must provide single object argument.");const{code:e,message:n,data:s}=t;if(!n||typeof n!="string")throw new Error('"message" must be a nonempty string');return new ht(e,n,s)}}};function M(t,e){const[n,s]=dt(e);return new ut(t,n||Re(t),s)}function se(t,e){const[n,s]=dt(e);return new ht(t,n||Re(t),s)}function dt(t){if(t){if(typeof t=="string")return[t];if(typeof t=="object"&&!Array.isArray(t)){const{message:e,data:n}=t;if(e&&typeof e!="string")throw new Error("Must specify string message.");return[e||void 0,n]}}return[]}class ut extends Error{constructor(e,n,s){if(!Number.isInteger(e))throw new Error('"code" must be an integer.');if(!n||typeof n!="string")throw new Error('"message" must be a nonempty string.');super(n),this.code=e,s!==void 0&&(this.data=s)}}class ht extends ut{constructor(e,n,s){if(!Nt(e))throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');super(e,n,s)}}function Nt(t){return Number.isInteger(t)&&t>=1e3&&t<=4999}function xe(){return t=>t}const de=xe(),Dt=xe(),qt=xe();function G(t){return Math.floor(t)}const lt=/^[0-9]*$/,ft=/^[a-f0-9]*$/;function ee(t){return Ue(crypto.getRandomValues(new Uint8Array(t)))}function Ue(t){return[...t].map(e=>e.toString(16).padStart(2,"0")).join("")}function le(t){return new Uint8Array(t.match(/.{1,2}/g).map(e=>Number.parseInt(e,16)))}function oe(t,e=!1){const n=t.toString("hex");return de(e?`0x${n}`:n)}function ge(t){return oe(Ae(t),!0)}function j(t){return qt(t.toString(10))}function Q(t){return de(`0x${BigInt(t).toString(16)}`)}function pt(t){return t.startsWith("0x")||t.startsWith("0X")}function Te(t){return pt(t)?t.slice(2):t}function gt(t){return pt(t)?`0x${t.slice(2)}`:`0x${t}`}function fe(t){if(typeof t!="string")return!1;const e=Te(t).toLowerCase();return ft.test(e)}function Ht(t,e=!1){if(typeof t=="string"){const n=Te(t).toLowerCase();if(ft.test(n))return de(e?`0x${n}`:n)}throw A.rpc.invalidParams(`"${String(t)}" is not a hexadecimal string`)}function Le(t,e=!1){let n=Ht(t,!1);return n.length%2===1&&(n=de(`0${n}`)),e?de(`0x${n}`):n}function J(t){if(typeof t=="string"){const e=Te(t).toLowerCase();if(fe(e)&&e.length===40)return Dt(gt(e))}throw A.rpc.invalidParams(`Invalid Ethereum address: ${String(t)}`)}function Ae(t){if(Buffer.isBuffer(t))return t;if(typeof t=="string"){if(fe(t)){const e=Le(t,!1);return Buffer.from(e,"hex")}return Buffer.from(t,"utf8")}throw A.rpc.invalidParams(`Not binary data: ${String(t)}`)}function ce(t){if(typeof t=="number"&&Number.isInteger(t))return G(t);if(typeof t=="string"){if(lt.test(t))return G(Number(t));if(fe(t))return G(Number(BigInt(Le(t,!0))))}throw A.rpc.invalidParams(`Not an integer: ${String(t)}`)}function re(t){if(t!==null&&(typeof t=="bigint"||Wt(t)))return BigInt(t.toString(10));if(typeof t=="number")return BigInt(ce(t));if(typeof t=="string"){if(lt.test(t))return BigInt(t);if(fe(t))return BigInt(Le(t,!0))}throw A.rpc.invalidParams(`Not an integer: ${String(t)}`)}function Kt(t){if(typeof t=="string")return JSON.parse(t);if(typeof t=="object")return t;throw A.rpc.invalidParams(`Not a JSON string or an object: ${String(t)}`)}function Wt(t){if(t==null||typeof t.constructor!="function")return!1;const{constructor:e}=t;return typeof e.config=="function"&&typeof e.EUCLID=="number"}async function Mt(){return crypto.subtle.generateKey({name:"ECDH",namedCurve:"P-256"},!0,["deriveKey"])}async function jt(t,e){return crypto.subtle.deriveKey({name:"ECDH",public:e},t,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"])}async function Ft(t,e){const n=crypto.getRandomValues(new Uint8Array(12)),s=await crypto.subtle.encrypt({name:"AES-GCM",iv:n},t,new TextEncoder().encode(e));return{iv:n,cipherText:s}}async function $t(t,{iv:e,cipherText:n}){const s=await crypto.subtle.decrypt({name:"AES-GCM",iv:e},t,n);return new TextDecoder().decode(s)}function yt(t){switch(t){case"public":return"spki";case"private":return"pkcs8"}}async function wt(t,e){const n=yt(t),s=await crypto.subtle.exportKey(n,e);return Ue(new Uint8Array(s))}async function mt(t,e){const n=yt(t),s=le(e).buffer;return await crypto.subtle.importKey(n,new Uint8Array(s),{name:"ECDH",namedCurve:"P-256"},!0,t==="private"?["deriveKey"]:[])}async function Gt(t,e){const n=JSON.stringify(t,(s,i)=>{if(!(i instanceof Error))return i;const r=i;return Object.assign(Object.assign({},r.code?{code:r.code}:{}),{message:r.message})});return Ft(e,n)}async function zt(t,e){return JSON.parse(await $t(e,t))}const ye={storageKey:"ownPrivateKey",keyType:"private"},we={storageKey:"ownPublicKey",keyType:"public"},me={storageKey:"peerPublicKey",keyType:"public"};class Vt{constructor(){this.storage=new $("CBWSDK","SCWKeyManager"),this.ownPrivateKey=null,this.ownPublicKey=null,this.peerPublicKey=null,this.sharedSecret=null}async getOwnPublicKey(){return await this.loadKeysIfNeeded(),this.ownPublicKey}async getSharedSecret(){return await this.loadKeysIfNeeded(),this.sharedSecret}async setPeerPublicKey(e){this.sharedSecret=null,this.peerPublicKey=e,await this.storeKey(me,e),await this.loadKeysIfNeeded()}async clear(){this.ownPrivateKey=null,this.ownPublicKey=null,this.peerPublicKey=null,this.sharedSecret=null,this.storage.removeItem(we.storageKey),this.storage.removeItem(ye.storageKey),this.storage.removeItem(me.storageKey)}async generateKeyPair(){const e=await Mt();this.ownPrivateKey=e.privateKey,this.ownPublicKey=e.publicKey,await this.storeKey(ye,e.privateKey),await this.storeKey(we,e.publicKey)}async loadKeysIfNeeded(){if(this.ownPrivateKey===null&&(this.ownPrivateKey=await this.loadKey(ye)),this.ownPublicKey===null&&(this.ownPublicKey=await this.loadKey(we)),(this.ownPrivateKey===null||this.ownPublicKey===null)&&await this.generateKeyPair(),this.peerPublicKey===null&&(this.peerPublicKey=await this.loadKey(me)),this.sharedSecret===null){if(this.ownPrivateKey===null||this.peerPublicKey===null)return;this.sharedSecret=await jt(this.ownPrivateKey,this.peerPublicKey)}}async loadKey(e){const n=this.storage.getItem(e.storageKey);return n?mt(e.keyType,n):null}async storeKey(e,n){const s=await wt(e.keyType,n);this.storage.setItem(e.storageKey,s)}}const ue="4.3.0",bt="@coinbase/wallet-sdk";async function Oe(t,e){const n=Object.assign(Object.assign({},t),{jsonrpc:"2.0",id:crypto.randomUUID()}),s=await window.fetch(e,{method:"POST",body:JSON.stringify(n),mode:"cors",headers:{"Content-Type":"application/json","X-Cbw-Sdk-Version":ue,"X-Cbw-Sdk-Platform":bt}}),{result:i,error:r}=await s.json();if(r)throw r;return i}function Jt(){return globalThis.coinbaseWalletExtension}function Yt(){var t,e;try{const n=globalThis;return(t=n.ethereum)!==null&&t!==void 0?t:(e=n.top)===null||e===void 0?void 0:e.ethereum}catch{return}}function Xt({metadata:t,preference:e}){var n,s;const{appName:i,appLogoUrl:r,appChainIds:a}=t;if(e.options!=="smartWalletOnly"){const h=Jt();if(h)return(n=h.setAppInfo)===null||n===void 0||n.call(h,i,r,a,e),h}const o=Yt();if(o!=null&&o.isCoinbaseBrowser)return(s=o.setAppInfo)===null||s===void 0||s.call(o,i,r,a,e),o}function Qt(t){if(!t||typeof t!="object"||Array.isArray(t))throw A.rpc.invalidParams({message:"Expected a single, non-array, object argument.",data:t});const{method:e,params:n}=t;if(typeof e!="string"||e.length===0)throw A.rpc.invalidParams({message:"'args.method' must be a non-empty string.",data:t});if(n!==void 0&&!Array.isArray(n)&&(typeof n!="object"||n===null))throw A.rpc.invalidParams({message:"'args.params' must be an object or array if provided.",data:t});switch(e){case"eth_sign":case"eth_signTypedData_v2":case"eth_subscribe":case"eth_unsubscribe":throw A.provider.unsupportedMethod()}}const We="accounts",Me="activeChain",je="availableChains",Fe="walletCapabilities";class Zt{constructor(e){var n,s,i;this.metadata=e.metadata,this.communicator=e.communicator,this.callback=e.callback,this.keyManager=new Vt,this.storage=new $("CBWSDK","SCWStateManager"),this.accounts=(n=this.storage.loadObject(We))!==null&&n!==void 0?n:[],this.chain=this.storage.loadObject(Me)||{id:(i=(s=e.metadata.appChainIds)===null||s===void 0?void 0:s[0])!==null&&i!==void 0?i:1},this.handshake=this.handshake.bind(this),this.request=this.request.bind(this),this.createRequestMessage=this.createRequestMessage.bind(this),this.decryptResponseMessage=this.decryptResponseMessage.bind(this)}async handshake(e){var n,s,i,r;await((s=(n=this.communicator).waitForPopupLoaded)===null||s===void 0?void 0:s.call(n));const a=await this.createRequestMessage({handshake:{method:e.method,params:Object.assign({},this.metadata,(i=e.params)!==null&&i!==void 0?i:{})}}),o=await this.communicator.postRequestAndWaitForResponse(a);if("failure"in o.content)throw o.content.failure;const h=await mt("public",o.sender);await this.keyManager.setPeerPublicKey(h);const b=(await this.decryptResponseMessage(o)).result;if("error"in b)throw b.error;switch(e.method){case"eth_requestAccounts":{const g=b.value;this.accounts=g,this.storage.storeObject(We,g),(r=this.callback)===null||r===void 0||r.call(this,"accountsChanged",g);break}}}async request(e){var n;if(this.accounts.length===0)switch(e.method){case"wallet_sendCalls":return this.sendRequestToPopup(e);default:throw A.provider.unauthorized()}switch(e.method){case"eth_requestAccounts":return(n=this.callback)===null||n===void 0||n.call(this,"connect",{chainId:Q(this.chain.id)}),this.accounts;case"eth_accounts":return this.accounts;case"eth_coinbase":return this.accounts[0];case"net_version":return this.chain.id;case"eth_chainId":return Q(this.chain.id);case"wallet_getCapabilities":return this.storage.loadObject(Fe);case"wallet_switchEthereumChain":return this.handleSwitchChainRequest(e);case"eth_ecRecover":case"personal_sign":case"wallet_sign":case"personal_ecRecover":case"eth_signTransaction":case"eth_sendTransaction":case"eth_signTypedData_v1":case"eth_signTypedData_v3":case"eth_signTypedData_v4":case"eth_signTypedData":case"wallet_addEthereumChain":case"wallet_watchAsset":case"wallet_sendCalls":case"wallet_showCallsStatus":case"wallet_grantPermissions":return this.sendRequestToPopup(e);default:if(!this.chain.rpcUrl)throw A.rpc.internal("No RPC URL set for chain");return Oe(e,this.chain.rpcUrl)}}async sendRequestToPopup(e){var n,s;await((s=(n=this.communicator).waitForPopupLoaded)===null||s===void 0?void 0:s.call(n));const i=await this.sendEncryptedRequest(e),a=(await this.decryptResponseMessage(i)).result;if("error"in a)throw a.error;return a.value}async cleanup(){var e,n;this.storage.clear(),await this.keyManager.clear(),this.accounts=[],this.chain={id:(n=(e=this.metadata.appChainIds)===null||e===void 0?void 0:e[0])!==null&&n!==void 0?n:1}}async handleSwitchChainRequest(e){var n;const s=e.params;if(!s||!(!((n=s[0])===null||n===void 0)&&n.chainId))throw A.rpc.invalidParams();const i=ce(s[0].chainId);if(this.updateChain(i))return null;const a=await this.sendRequestToPopup(e);return a===null&&this.updateChain(i),a}async sendEncryptedRequest(e){const n=await this.keyManager.getSharedSecret();if(!n)throw A.provider.unauthorized("No valid session found, try requestAccounts before other methods");const s=await Gt({action:e,chainId:this.chain.id},n),i=await this.createRequestMessage({encrypted:s});return this.communicator.postRequestAndWaitForResponse(i)}async createRequestMessage(e){const n=await wt("public",await this.keyManager.getOwnPublicKey());return{id:crypto.randomUUID(),sender:n,content:e,timestamp:new Date}}async decryptResponseMessage(e){var n,s;const i=e.content;if("failure"in i)throw i.failure;const r=await this.keyManager.getSharedSecret();if(!r)throw A.provider.unauthorized("Invalid session");const a=await zt(i.encrypted,r),o=(n=a.data)===null||n===void 0?void 0:n.chains;if(o){const f=Object.entries(o).map(([b,g])=>({id:Number(b),rpcUrl:g}));this.storage.storeObject(je,f),this.updateChain(this.chain.id,f)}const h=(s=a.data)===null||s===void 0?void 0:s.capabilities;return h&&this.storage.storeObject(Fe,h),a}updateChain(e,n){var s;const i=n??this.storage.loadObject(je),r=i==null?void 0:i.find(a=>a.id===e);return r?(r!==this.chain&&(this.chain=r,this.storage.storeObject(Me,r),(s=this.callback)===null||s===void 0||s.call(this,"chainChanged",Q(r.id))),!0):!1}}var T={},I={},$e;function en(){if($e)return I;$e=1,Object.defineProperty(I,"__esModule",{value:!0}),I.toBig=I.shrSL=I.shrSH=I.rotrSL=I.rotrSH=I.rotrBL=I.rotrBH=I.rotr32L=I.rotr32H=I.rotlSL=I.rotlSH=I.rotlBL=I.rotlBH=I.add5L=I.add5H=I.add4L=I.add4H=I.add3L=I.add3H=void 0,I.add=C,I.fromBig=n,I.split=s;const t=BigInt(2**32-1),e=BigInt(32);function n(y,p=!1){return p?{h:Number(y&t),l:Number(y>>e&t)}:{h:Number(y>>e&t)|0,l:Number(y&t)|0}}function s(y,p=!1){const w=y.length;let B=new Uint32Array(w),D=new Uint32Array(w);for(let q=0;q<w;q++){const{h:te,l:ne}=n(y[q],p);[B[q],D[q]]=[te,ne]}return[B,D]}const i=(y,p)=>BigInt(y>>>0)<<e|BigInt(p>>>0);I.toBig=i;const r=(y,p,w)=>y>>>w;I.shrSH=r;const a=(y,p,w)=>y<<32-w|p>>>w;I.shrSL=a;const o=(y,p,w)=>y>>>w|p<<32-w;I.rotrSH=o;const h=(y,p,w)=>y<<32-w|p>>>w;I.rotrSL=h;const f=(y,p,w)=>y<<64-w|p>>>w-32;I.rotrBH=f;const b=(y,p,w)=>y>>>w-32|p<<64-w;I.rotrBL=b;const g=(y,p)=>p;I.rotr32H=g;const u=(y,p)=>y;I.rotr32L=u;const c=(y,p,w)=>y<<w|p>>>32-w;I.rotlSH=c;const l=(y,p,w)=>p<<w|y>>>32-w;I.rotlSL=l;const S=(y,p,w)=>p<<w-32|y>>>64-w;I.rotlBH=S;const _=(y,p,w)=>y<<w-32|p>>>64-w;I.rotlBL=_;function C(y,p,w,B){const D=(p>>>0)+(B>>>0);return{h:y+w+(D/2**32|0)|0,l:D|0}}const x=(y,p,w)=>(y>>>0)+(p>>>0)+(w>>>0);I.add3L=x;const P=(y,p,w,B)=>p+w+B+(y/2**32|0)|0;I.add3H=P;const E=(y,p,w,B)=>(y>>>0)+(p>>>0)+(w>>>0)+(B>>>0);I.add4L=E;const m=(y,p,w,B,D)=>p+w+B+D+(y/2**32|0)|0;I.add4H=m;const k=(y,p,w,B,D)=>(y>>>0)+(p>>>0)+(w>>>0)+(B>>>0)+(D>>>0);I.add5L=k;const R=(y,p,w,B,D,q)=>p+w+B+D+q+(y/2**32|0)|0;I.add5H=R;const U={fromBig:n,split:s,toBig:i,shrSH:r,shrSL:a,rotrSH:o,rotrSL:h,rotrBH:f,rotrBL:b,rotr32H:g,rotr32L:u,rotlSH:c,rotlSL:l,rotlBH:S,rotlBL:_,add:C,add3L:x,add3H:P,add4L:E,add4H:m,add5H:R,add5L:k};return I.default=U,I}var be={},ae={},Ge;function tn(){return Ge||(Ge=1,Object.defineProperty(ae,"__esModule",{value:!0}),ae.crypto=void 0,ae.crypto=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0),ae}var ze;function nn(){return ze||(ze=1,(function(t){/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */Object.defineProperty(t,"__esModule",{value:!0}),t.wrapXOFConstructorWithOpts=t.wrapConstructorWithOpts=t.wrapConstructor=t.Hash=t.nextTick=t.swap32IfBE=t.byteSwapIfBE=t.swap8IfBE=t.isLE=void 0,t.isBytes=n,t.anumber=s,t.abytes=i,t.ahash=r,t.aexists=a,t.aoutput=o,t.u8=h,t.u32=f,t.clean=b,t.createView=g,t.rotr=u,t.rotl=c,t.byteSwap=l,t.byteSwap32=S,t.bytesToHex=x,t.hexToBytes=m,t.asyncLoop=R,t.utf8ToBytes=U,t.bytesToUtf8=y,t.toBytes=p,t.kdfInputToBytes=w,t.concatBytes=B,t.checkOpts=D,t.createHasher=te,t.createOptHasher=ne,t.createXOFer=Z,t.randomBytes=kt;const e=tn();function n(d){return d instanceof Uint8Array||ArrayBuffer.isView(d)&&d.constructor.name==="Uint8Array"}function s(d){if(!Number.isSafeInteger(d)||d<0)throw new Error("positive integer expected, got "+d)}function i(d,...v){if(!n(d))throw new Error("Uint8Array expected");if(v.length>0&&!v.includes(d.length))throw new Error("Uint8Array expected of length "+v+", got length="+d.length)}function r(d){if(typeof d!="function"||typeof d.create!="function")throw new Error("Hash should be wrapped by utils.createHasher");s(d.outputLen),s(d.blockLen)}function a(d,v=!0){if(d.destroyed)throw new Error("Hash instance has been destroyed");if(v&&d.finished)throw new Error("Hash#digest() has already been called")}function o(d,v){i(d);const L=v.outputLen;if(d.length<L)throw new Error("digestInto() expects output buffer of length at least "+L)}function h(d){return new Uint8Array(d.buffer,d.byteOffset,d.byteLength)}function f(d){return new Uint32Array(d.buffer,d.byteOffset,Math.floor(d.byteLength/4))}function b(...d){for(let v=0;v<d.length;v++)d[v].fill(0)}function g(d){return new DataView(d.buffer,d.byteOffset,d.byteLength)}function u(d,v){return d<<32-v|d>>>v}function c(d,v){return d<<v|d>>>32-v>>>0}t.isLE=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function l(d){return d<<24&4278190080|d<<8&16711680|d>>>8&65280|d>>>24&255}t.swap8IfBE=t.isLE?d=>d:d=>l(d),t.byteSwapIfBE=t.swap8IfBE;function S(d){for(let v=0;v<d.length;v++)d[v]=l(d[v]);return d}t.swap32IfBE=t.isLE?d=>d:S;const _=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",C=Array.from({length:256},(d,v)=>v.toString(16).padStart(2,"0"));function x(d){if(i(d),_)return d.toHex();let v="";for(let L=0;L<d.length;L++)v+=C[d[L]];return v}const P={_0:48,_9:57,A:65,F:70,a:97,f:102};function E(d){if(d>=P._0&&d<=P._9)return d-P._0;if(d>=P.A&&d<=P.F)return d-(P.A-10);if(d>=P.a&&d<=P.f)return d-(P.a-10)}function m(d){if(typeof d!="string")throw new Error("hex string expected, got "+typeof d);if(_)return Uint8Array.fromHex(d);const v=d.length,L=v/2;if(v%2)throw new Error("hex string expected, got unpadded hex of length "+v);const O=new Uint8Array(L);for(let H=0,W=0;H<L;H++,W+=2){const Be=E(d.charCodeAt(W)),Ne=E(d.charCodeAt(W+1));if(Be===void 0||Ne===void 0){const At=d[W]+d[W+1];throw new Error('hex string expected, got non-hex character "'+At+'" at index '+W)}O[H]=Be*16+Ne}return O}const k=async()=>{};t.nextTick=k;async function R(d,v,L){let O=Date.now();for(let H=0;H<d;H++){L(H);const W=Date.now()-O;W>=0&&W<v||(await(0,t.nextTick)(),O+=W)}}function U(d){if(typeof d!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(d))}function y(d){return new TextDecoder().decode(d)}function p(d){return typeof d=="string"&&(d=U(d)),i(d),d}function w(d){return typeof d=="string"&&(d=U(d)),i(d),d}function B(...d){let v=0;for(let O=0;O<d.length;O++){const H=d[O];i(H),v+=H.length}const L=new Uint8Array(v);for(let O=0,H=0;O<d.length;O++){const W=d[O];L.set(W,H),H+=W.length}return L}function D(d,v){if(v!==void 0&&{}.toString.call(v)!=="[object Object]")throw new Error("options should be object or undefined");return Object.assign(d,v)}class q{}t.Hash=q;function te(d){const v=O=>d().update(p(O)).digest(),L=d();return v.outputLen=L.outputLen,v.blockLen=L.blockLen,v.create=()=>d(),v}function ne(d){const v=(O,H)=>d(H).update(p(O)).digest(),L=d({});return v.outputLen=L.outputLen,v.blockLen=L.blockLen,v.create=O=>d(O),v}function Z(d){const v=(O,H)=>d(H).update(p(O)).digest(),L=d({});return v.outputLen=L.outputLen,v.blockLen=L.blockLen,v.create=O=>d(O),v}t.wrapConstructor=te,t.wrapConstructorWithOpts=ne,t.wrapXOFConstructorWithOpts=Z;function kt(d=32){if(e.crypto&&typeof e.crypto.getRandomValues=="function")return e.crypto.getRandomValues(new Uint8Array(d));if(e.crypto&&typeof e.crypto.randomBytes=="function")return Uint8Array.from(e.crypto.randomBytes(d));throw new Error("crypto.getRandomValues must be defined")}})(be)),be}var Ve;function sn(){if(Ve)return T;Ve=1,Object.defineProperty(T,"__esModule",{value:!0}),T.shake256=T.shake128=T.keccak_512=T.keccak_384=T.keccak_256=T.keccak_224=T.sha3_512=T.sha3_384=T.sha3_256=T.sha3_224=T.Keccak=void 0,T.keccakP=_;const t=en(),e=nn(),n=BigInt(0),s=BigInt(1),i=BigInt(2),r=BigInt(7),a=BigInt(256),o=BigInt(113),h=[],f=[],b=[];for(let E=0,m=s,k=1,R=0;E<24;E++){[k,R]=[R,(2*k+3*R)%5],h.push(2*(5*R+k)),f.push((E+1)*(E+2)/2%64);let U=n;for(let y=0;y<7;y++)m=(m<<s^(m>>r)*o)%a,m&i&&(U^=s<<(s<<BigInt(y))-s);b.push(U)}const g=(0,t.split)(b,!0),u=g[0],c=g[1],l=(E,m,k)=>k>32?(0,t.rotlBH)(E,m,k):(0,t.rotlSH)(E,m,k),S=(E,m,k)=>k>32?(0,t.rotlBL)(E,m,k):(0,t.rotlSL)(E,m,k);function _(E,m=24){const k=new Uint32Array(10);for(let R=24-m;R<24;R++){for(let p=0;p<10;p++)k[p]=E[p]^E[p+10]^E[p+20]^E[p+30]^E[p+40];for(let p=0;p<10;p+=2){const w=(p+8)%10,B=(p+2)%10,D=k[B],q=k[B+1],te=l(D,q,1)^k[w],ne=S(D,q,1)^k[w+1];for(let Z=0;Z<50;Z+=10)E[p+Z]^=te,E[p+Z+1]^=ne}let U=E[2],y=E[3];for(let p=0;p<24;p++){const w=f[p],B=l(U,y,w),D=S(U,y,w),q=h[p];U=E[q],y=E[q+1],E[q]=B,E[q+1]=D}for(let p=0;p<50;p+=10){for(let w=0;w<10;w++)k[w]=E[p+w];for(let w=0;w<10;w++)E[p+w]^=~k[(w+2)%10]&k[(w+4)%10]}E[0]^=u[R],E[1]^=c[R]}(0,e.clean)(k)}class C extends e.Hash{constructor(m,k,R,U=!1,y=24){if(super(),this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,this.enableXOF=!1,this.blockLen=m,this.suffix=k,this.outputLen=R,this.enableXOF=U,this.rounds=y,(0,e.anumber)(R),!(0<m&&m<200))throw new Error("only keccak-f1600 function is supported");this.state=new Uint8Array(200),this.state32=(0,e.u32)(this.state)}clone(){return this._cloneInto()}keccak(){(0,e.swap32IfBE)(this.state32),_(this.state32,this.rounds),(0,e.swap32IfBE)(this.state32),this.posOut=0,this.pos=0}update(m){(0,e.aexists)(this),m=(0,e.toBytes)(m),(0,e.abytes)(m);const{blockLen:k,state:R}=this,U=m.length;for(let y=0;y<U;){const p=Math.min(k-this.pos,U-y);for(let w=0;w<p;w++)R[this.pos++]^=m[y++];this.pos===k&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:m,suffix:k,pos:R,blockLen:U}=this;m[R]^=k,(k&128)!==0&&R===U-1&&this.keccak(),m[U-1]^=128,this.keccak()}writeInto(m){(0,e.aexists)(this,!1),(0,e.abytes)(m),this.finish();const k=this.state,{blockLen:R}=this;for(let U=0,y=m.length;U<y;){this.posOut>=R&&this.keccak();const p=Math.min(R-this.posOut,y-U);m.set(k.subarray(this.posOut,this.posOut+p),U),this.posOut+=p,U+=p}return m}xofInto(m){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(m)}xof(m){return(0,e.anumber)(m),this.xofInto(new Uint8Array(m))}digestInto(m){if((0,e.aoutput)(m,this),this.finished)throw new Error("digest() was already called");return this.writeInto(m),this.destroy(),m}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,(0,e.clean)(this.state)}_cloneInto(m){const{blockLen:k,suffix:R,outputLen:U,rounds:y,enableXOF:p}=this;return m||(m=new C(k,R,U,p,y)),m.state32.set(this.state32),m.pos=this.pos,m.posOut=this.posOut,m.finished=this.finished,m.rounds=y,m.suffix=R,m.outputLen=U,m.enableXOF=p,m.destroyed=this.destroyed,m}}T.Keccak=C;const x=(E,m,k)=>(0,e.createHasher)(()=>new C(m,E,k));T.sha3_224=x(6,144,224/8),T.sha3_256=x(6,136,256/8),T.sha3_384=x(6,104,384/8),T.sha3_512=x(6,72,512/8),T.keccak_224=x(1,144,224/8),T.keccak_256=x(1,136,256/8),T.keccak_384=x(1,104,384/8),T.keccak_512=x(1,72,512/8);const P=(E,m,k)=>(0,e.createXOFer)((R={})=>new C(m,E,R.dkLen===void 0?k:R.dkLen,!0));return T.shake128=P(31,168,128/8),T.shake256=P(31,136,256/8),T}var ve,Je;function vt(){if(Je)return ve;Je=1;const{keccak_256:t}=sn();function e(c){return Buffer.allocUnsafe(c).fill(0)}function n(c){return c.toString(2).length}function s(c,l){let S=c.toString(16);S.length%2!==0&&(S="0"+S);const _=S.match(/.{1,2}/g).map(C=>parseInt(C,16));for(;_.length<l;)_.unshift(0);return Buffer.from(_)}function i(c,l){const S=c<0n;let _;if(S){const C=(1n<<BigInt(l))-1n;_=(~c&C)+1n}else _=c;return _&=(1n<<BigInt(l))-1n,_}function r(c,l,S){const _=e(l);return c=o(c),S?c.length<l?(c.copy(_),_):c.slice(0,l):c.length<l?(c.copy(_,l-c.length),_):c.slice(-l)}function a(c,l){return r(c,l,!0)}function o(c){if(!Buffer.isBuffer(c))if(Array.isArray(c))c=Buffer.from(c);else if(typeof c=="string")g(c)?c=Buffer.from(b(u(c)),"hex"):c=Buffer.from(c);else if(typeof c=="number")c=intToBuffer(c);else if(c==null)c=Buffer.allocUnsafe(0);else if(typeof c=="bigint")c=s(c);else if(c.toArray)c=Buffer.from(c.toArray());else throw new Error("invalid type");return c}function h(c){return c=o(c),"0x"+c.toString("hex")}function f(c,l){if(c=o(c),l||(l=256),l!==256)throw new Error("unsupported");return Buffer.from(t(new Uint8Array(c)))}function b(c){return c.length%2?"0"+c:c}function g(c){return typeof c=="string"&&c.match(/^0x[0-9A-Fa-f]*$/)}function u(c){return typeof c=="string"&&c.startsWith("0x")?c.slice(2):c}return ve={zeros:e,setLength:r,setLengthRight:a,isHexString:g,stripHexPrefix:u,toBuffer:o,bufferToHex:h,keccak:f,bitLengthFromBigInt:n,bufferBEFromBigInt:s,twosFromBigInt:i},ve}var Ee,Ye;function rn(){if(Ye)return Ee;Ye=1;const t=vt();function e(u){return u.startsWith("int[")?"int256"+u.slice(3):u==="int"?"int256":u.startsWith("uint[")?"uint256"+u.slice(4):u==="uint"?"uint256":u.startsWith("fixed[")?"fixed128x128"+u.slice(5):u==="fixed"?"fixed128x128":u.startsWith("ufixed[")?"ufixed128x128"+u.slice(6):u==="ufixed"?"ufixed128x128":u}function n(u){return Number.parseInt(/^\D+(\d+)$/.exec(u)[1],10)}function s(u){var c=/^\D+(\d+)x(\d+)$/.exec(u);return[Number.parseInt(c[1],10),Number.parseInt(c[2],10)]}function i(u){var c=u.match(/(.*)\[(.*?)\]$/);return c?c[2]===""?"dynamic":Number.parseInt(c[2],10):null}function r(u){var c=typeof u;if(c==="string"||c==="number")return BigInt(u);if(c==="bigint")return u;throw new Error("Argument is not a number")}function a(u,c){var l,S,_,C;if(u==="address")return a("uint160",r(c));if(u==="bool")return a("uint8",c?1:0);if(u==="string")return a("bytes",new Buffer(c,"utf8"));if(h(u)){if(typeof c.length>"u")throw new Error("Not an array?");if(l=i(u),l!=="dynamic"&&l!==0&&c.length>l)throw new Error("Elements exceed array size: "+l);_=[],u=u.slice(0,u.lastIndexOf("[")),typeof c=="string"&&(c=JSON.parse(c));for(C in c)_.push(a(u,c[C]));if(l==="dynamic"){var x=a("uint256",c.length);_.unshift(x)}return Buffer.concat(_)}else{if(u==="bytes")return c=new Buffer(c),_=Buffer.concat([a("uint256",c.length),c]),c.length%32!==0&&(_=Buffer.concat([_,t.zeros(32-c.length%32)])),_;if(u.startsWith("bytes")){if(l=n(u),l<1||l>32)throw new Error("Invalid bytes<N> width: "+l);return t.setLengthRight(c,32)}else if(u.startsWith("uint")){if(l=n(u),l%8||l<8||l>256)throw new Error("Invalid uint<N> width: "+l);S=r(c);const P=t.bitLengthFromBigInt(S);if(P>l)throw new Error("Supplied uint exceeds width: "+l+" vs "+P);if(S<0)throw new Error("Supplied uint is negative");return t.bufferBEFromBigInt(S,32)}else if(u.startsWith("int")){if(l=n(u),l%8||l<8||l>256)throw new Error("Invalid int<N> width: "+l);S=r(c);const P=t.bitLengthFromBigInt(S);if(P>l)throw new Error("Supplied int exceeds width: "+l+" vs "+P);const E=t.twosFromBigInt(S,256);return t.bufferBEFromBigInt(E,32)}else if(u.startsWith("ufixed")){if(l=s(u),S=r(c),S<0)throw new Error("Supplied ufixed is negative");return a("uint256",S*BigInt(2)**BigInt(l[1]))}else if(u.startsWith("fixed"))return l=s(u),a("int256",r(c)*BigInt(2)**BigInt(l[1]))}throw new Error("Unsupported or invalid type: "+u)}function o(u){return u==="string"||u==="bytes"||i(u)==="dynamic"}function h(u){return u.lastIndexOf("]")===u.length-1}function f(u,c){var l=[],S=[],_=32*u.length;for(var C in u){var x=e(u[C]),P=c[C],E=a(x,P);o(x)?(l.push(a("uint256",_)),S.push(E),_+=E.length):l.push(E)}return Buffer.concat(l.concat(S))}function b(u,c){if(u.length!==c.length)throw new Error("Number of types are not matching the values");for(var l,S,_=[],C=0;C<u.length;C++){var x=e(u[C]),P=c[C];if(x==="bytes")_.push(P);else if(x==="string")_.push(new Buffer(P,"utf8"));else if(x==="bool")_.push(new Buffer(P?"01":"00","hex"));else if(x==="address")_.push(t.setLength(P,20));else if(x.startsWith("bytes")){if(l=n(x),l<1||l>32)throw new Error("Invalid bytes<N> width: "+l);_.push(t.setLengthRight(P,l))}else if(x.startsWith("uint")){if(l=n(x),l%8||l<8||l>256)throw new Error("Invalid uint<N> width: "+l);S=r(P);const E=t.bitLengthFromBigInt(S);if(E>l)throw new Error("Supplied uint exceeds width: "+l+" vs "+E);_.push(t.bufferBEFromBigInt(S,l/8))}else if(x.startsWith("int")){if(l=n(x),l%8||l<8||l>256)throw new Error("Invalid int<N> width: "+l);S=r(P);const E=t.bitLengthFromBigInt(S);if(E>l)throw new Error("Supplied int exceeds width: "+l+" vs "+E);const m=t.twosFromBigInt(S,l);_.push(t.bufferBEFromBigInt(m,l/8))}else throw new Error("Unsupported or invalid type: "+x)}return Buffer.concat(_)}function g(u,c){return t.keccak(b(u,c))}return Ee={rawEncode:f,solidityPack:b,soliditySHA3:g},Ee}var _e,Xe;function an(){if(Xe)return _e;Xe=1;const t=vt(),e=rn(),n={type:"object",properties:{types:{type:"object",additionalProperties:{type:"array",items:{type:"object",properties:{name:{type:"string"},type:{type:"string"}},required:["name","type"]}}},primaryType:{type:"string"},domain:{type:"object"},message:{type:"object"}},required:["types","primaryType","domain","message"]},s={encodeData(r,a,o,h=!0){const f=["bytes32"],b=[this.hashType(r,o)];if(h){const g=(u,c,l)=>{if(o[c]!==void 0)return["bytes32",l==null?"0x0000000000000000000000000000000000000000000000000000000000000000":t.keccak(this.encodeData(c,l,o,h))];if(l===void 0)throw new Error(`missing value for field ${u} of type ${c}`);if(c==="bytes")return["bytes32",t.keccak(l)];if(c==="string")return typeof l=="string"&&(l=Buffer.from(l,"utf8")),["bytes32",t.keccak(l)];if(c.lastIndexOf("]")===c.length-1){const S=c.slice(0,c.lastIndexOf("[")),_=l.map(C=>g(u,S,C));return["bytes32",t.keccak(e.rawEncode(_.map(([C])=>C),_.map(([,C])=>C)))]}return[c,l]};for(const u of o[r]){const[c,l]=g(u.name,u.type,a[u.name]);f.push(c),b.push(l)}}else for(const g of o[r]){let u=a[g.name];if(u!==void 0)if(g.type==="bytes")f.push("bytes32"),u=t.keccak(u),b.push(u);else if(g.type==="string")f.push("bytes32"),typeof u=="string"&&(u=Buffer.from(u,"utf8")),u=t.keccak(u),b.push(u);else if(o[g.type]!==void 0)f.push("bytes32"),u=t.keccak(this.encodeData(g.type,u,o,h)),b.push(u);else{if(g.type.lastIndexOf("]")===g.type.length-1)throw new Error("Arrays currently unimplemented in encodeData");f.push(g.type),b.push(u)}}return e.rawEncode(f,b)},encodeType(r,a){let o="",h=this.findTypeDependencies(r,a).filter(f=>f!==r);h=[r].concat(h.sort());for(const f of h){if(!a[f])throw new Error("No type definition specified: "+f);o+=f+"("+a[f].map(({name:g,type:u})=>u+" "+g).join(",")+")"}return o},findTypeDependencies(r,a,o=[]){if(r=r.match(/^\w*/)[0],o.includes(r)||a[r]===void 0)return o;o.push(r);for(const h of a[r])for(const f of this.findTypeDependencies(h.type,a,o))!o.includes(f)&&o.push(f);return o},hashStruct(r,a,o,h=!0){return t.keccak(this.encodeData(r,a,o,h))},hashType(r,a){return t.keccak(this.encodeType(r,a))},sanitizeData(r){const a={};for(const o in n.properties)r[o]&&(a[o]=r[o]);return a.types&&(a.types=Object.assign({EIP712Domain:[]},a.types)),a},hash(r,a=!0){const o=this.sanitizeData(r),h=[Buffer.from("1901","hex")];return h.push(this.hashStruct("EIP712Domain",o.domain,o.types,a)),o.primaryType!=="EIP712Domain"&&h.push(this.hashStruct(o.primaryType,o.message,o.types,a)),t.keccak(Buffer.concat(h))}};_e={TYPED_MESSAGE_SCHEMA:n,TypedDataUtils:s,hashForSignTypedDataLegacy:function(r){return i(r.data)},hashForSignTypedData_v3:function(r){return s.hash(r.data,!1)},hashForSignTypedData_v4:function(r){return s.hash(r.data)}};function i(r){const a=new Error("Expect argument to be non-empty array");if(typeof r!="object"||!r.length)throw a;const o=r.map(function(b){return b.type==="bytes"?t.toBuffer(b.value):b.value}),h=r.map(function(b){return b.type}),f=r.map(function(b){if(!b.name)throw a;return b.type+" "+b.name});return e.soliditySHA3(["bytes32","bytes32"],[e.soliditySHA3(new Array(r.length).fill("string"),f),e.soliditySHA3(h,o)])}return _e}var on=an();const he=Ct(on),cn="walletUsername",Ce="Addresses",dn="AppVersion";function K(t){return t.errorMessage!==void 0}class un{constructor(e){this.secret=e}async encrypt(e){const n=this.secret;if(n.length!==64)throw Error("secret must be 256 bits");const s=crypto.getRandomValues(new Uint8Array(12)),i=await crypto.subtle.importKey("raw",le(n),{name:"aes-gcm"},!1,["encrypt","decrypt"]),r=new TextEncoder,a=await window.crypto.subtle.encrypt({name:"AES-GCM",iv:s},i,r.encode(e)),o=16,h=a.slice(a.byteLength-o),f=a.slice(0,a.byteLength-o),b=new Uint8Array(h),g=new Uint8Array(f),u=new Uint8Array([...s,...b,...g]);return Ue(u)}async decrypt(e){const n=this.secret;if(n.length!==64)throw Error("secret must be 256 bits");return new Promise((s,i)=>{(async function(){const r=await crypto.subtle.importKey("raw",le(n),{name:"aes-gcm"},!1,["encrypt","decrypt"]),a=le(e),o=a.slice(0,12),h=a.slice(12,28),f=a.slice(28),b=new Uint8Array([...f,...h]),g={name:"AES-GCM",iv:new Uint8Array(o)};try{const u=await window.crypto.subtle.decrypt(g,r,b),c=new TextDecoder;s(c.decode(u))}catch(u){i(u)}})()})}}class hn{constructor(e,n,s){this.linkAPIUrl=e,this.sessionId=n;const i=`${n}:${s}`;this.auth=`Basic ${btoa(i)}`}async markUnseenEventsAsSeen(e){return Promise.all(e.map(n=>fetch(`${this.linkAPIUrl}/events/${n.eventId}/seen`,{method:"POST",headers:{Authorization:this.auth}}))).catch(n=>console.error("Unabled to mark event as failed:",n))}async fetchUnseenEvents(){var e;const n=await fetch(`${this.linkAPIUrl}/events?unseen=true`,{headers:{Authorization:this.auth}});if(n.ok){const{events:s,error:i}=await n.json();if(i)throw new Error(`Check unseen events failed: ${i}`);const r=(e=s==null?void 0:s.filter(a=>a.event==="Web3Response").map(a=>({type:"Event",sessionId:this.sessionId,eventId:a.id,event:a.event,data:a.data})))!==null&&e!==void 0?e:[];return this.markUnseenEventsAsSeen(r),r}throw new Error(`Check unseen events failed: ${n.status}`)}}var V;(function(t){t[t.DISCONNECTED=0]="DISCONNECTED",t[t.CONNECTING=1]="CONNECTING",t[t.CONNECTED=2]="CONNECTED"})(V||(V={}));class ln{setConnectionStateListener(e){this.connectionStateListener=e}setIncomingDataListener(e){this.incomingDataListener=e}constructor(e,n=WebSocket){this.WebSocketClass=n,this.webSocket=null,this.pendingData=[],this.url=e.replace(/^http/,"ws")}async connect(){if(this.webSocket)throw new Error("webSocket object is not null");return new Promise((e,n)=>{var s;let i;try{this.webSocket=i=new this.WebSocketClass(this.url)}catch(r){n(r);return}(s=this.connectionStateListener)===null||s===void 0||s.call(this,V.CONNECTING),i.onclose=r=>{var a;this.clearWebSocket(),n(new Error(`websocket error ${r.code}: ${r.reason}`)),(a=this.connectionStateListener)===null||a===void 0||a.call(this,V.DISCONNECTED)},i.onopen=r=>{var a;e(),(a=this.connectionStateListener)===null||a===void 0||a.call(this,V.CONNECTED),this.pendingData.length>0&&([...this.pendingData].forEach(h=>this.sendData(h)),this.pendingData=[])},i.onmessage=r=>{var a,o;if(r.data==="h")(a=this.incomingDataListener)===null||a===void 0||a.call(this,{type:"Heartbeat"});else try{const h=JSON.parse(r.data);(o=this.incomingDataListener)===null||o===void 0||o.call(this,h)}catch{}}})}disconnect(){var e;const{webSocket:n}=this;if(n){this.clearWebSocket(),(e=this.connectionStateListener)===null||e===void 0||e.call(this,V.DISCONNECTED),this.connectionStateListener=void 0,this.incomingDataListener=void 0;try{n.close()}catch{}}}sendData(e){const{webSocket:n}=this;if(!n){this.pendingData.push(e),this.connect();return}n.send(e)}clearWebSocket(){const{webSocket:e}=this;e&&(this.webSocket=null,e.onclose=null,e.onerror=null,e.onmessage=null,e.onopen=null)}}const Qe=1e4,fn=6e4;class pn{constructor({session:e,linkAPIUrl:n,listener:s}){this.destroyed=!1,this.lastHeartbeatResponse=0,this.nextReqId=G(1),this._connected=!1,this._linked=!1,this.shouldFetchUnseenEventsOnConnect=!1,this.requestResolutions=new Map,this.handleSessionMetadataUpdated=r=>{if(!r)return;new Map([["__destroyed",this.handleDestroyed],["EthereumAddress",this.handleAccountUpdated],["WalletUsername",this.handleWalletUsernameUpdated],["AppVersion",this.handleAppVersionUpdated],["ChainId",o=>r.JsonRpcUrl&&this.handleChainUpdated(o,r.JsonRpcUrl)]]).forEach((o,h)=>{const f=r[h];f!==void 0&&o(f)})},this.handleDestroyed=r=>{var a;r==="1"&&((a=this.listener)===null||a===void 0||a.resetAndReload())},this.handleAccountUpdated=async r=>{var a;const o=await this.cipher.decrypt(r);(a=this.listener)===null||a===void 0||a.accountUpdated(o)},this.handleMetadataUpdated=async(r,a)=>{var o;const h=await this.cipher.decrypt(a);(o=this.listener)===null||o===void 0||o.metadataUpdated(r,h)},this.handleWalletUsernameUpdated=async r=>{this.handleMetadataUpdated(cn,r)},this.handleAppVersionUpdated=async r=>{this.handleMetadataUpdated(dn,r)},this.handleChainUpdated=async(r,a)=>{var o;const h=await this.cipher.decrypt(r),f=await this.cipher.decrypt(a);(o=this.listener)===null||o===void 0||o.chainUpdated(h,f)},this.session=e,this.cipher=new un(e.secret),this.listener=s;const i=new ln(`${n}/rpc`,WebSocket);i.setConnectionStateListener(async r=>{let a=!1;switch(r){case V.DISCONNECTED:if(!this.destroyed){const o=async()=>{await new Promise(h=>setTimeout(h,5e3)),this.destroyed||i.connect().catch(()=>{o()})};o()}break;case V.CONNECTED:a=await this.handleConnected(),this.updateLastHeartbeat(),setInterval(()=>{this.heartbeat()},Qe),this.shouldFetchUnseenEventsOnConnect&&this.fetchUnseenEventsAPI();break;case V.CONNECTING:break}this.connected!==a&&(this.connected=a)}),i.setIncomingDataListener(r=>{var a;switch(r.type){case"Heartbeat":this.updateLastHeartbeat();return;case"IsLinkedOK":case"Linked":{const o=r.type==="IsLinkedOK"?r.linked:void 0;this.linked=o||r.onlineGuests>0;break}case"GetSessionConfigOK":case"SessionConfigUpdated":{this.handleSessionMetadataUpdated(r.metadata);break}case"Event":{this.handleIncomingEvent(r);break}}r.id!==void 0&&((a=this.requestResolutions.get(r.id))===null||a===void 0||a(r))}),this.ws=i,this.http=new hn(n,e.id,e.key)}connect(){if(this.destroyed)throw new Error("instance is destroyed");this.ws.connect()}async destroy(){this.destroyed||(await this.makeRequest({type:"SetSessionConfig",id:G(this.nextReqId++),sessionId:this.session.id,metadata:{__destroyed:"1"}},{timeout:1e3}),this.destroyed=!0,this.ws.disconnect(),this.listener=void 0)}get connected(){return this._connected}set connected(e){this._connected=e}get linked(){return this._linked}set linked(e){var n,s;this._linked=e,e&&((n=this.onceLinked)===null||n===void 0||n.call(this)),(s=this.listener)===null||s===void 0||s.linkedUpdated(e)}setOnceLinked(e){return new Promise(n=>{this.linked?e().then(n):this.onceLinked=()=>{e().then(n),this.onceLinked=void 0}})}async handleIncomingEvent(e){var n;if(e.type!=="Event"||e.event!=="Web3Response")return;const s=await this.cipher.decrypt(e.data),i=JSON.parse(s);if(i.type!=="WEB3_RESPONSE")return;const{id:r,response:a}=i;(n=this.listener)===null||n===void 0||n.handleWeb3ResponseMessage(r,a)}async checkUnseenEvents(){if(!this.connected){this.shouldFetchUnseenEventsOnConnect=!0;return}await new Promise(e=>setTimeout(e,250));try{await this.fetchUnseenEventsAPI()}catch(e){console.error("Unable to check for unseen events",e)}}async fetchUnseenEventsAPI(){this.shouldFetchUnseenEventsOnConnect=!1,(await this.http.fetchUnseenEvents()).forEach(n=>this.handleIncomingEvent(n))}async publishEvent(e,n,s=!1){const i=await this.cipher.encrypt(JSON.stringify(Object.assign(Object.assign({},n),{origin:location.origin,location:location.href,relaySource:"coinbaseWalletExtension"in window&&window.coinbaseWalletExtension?"injected_sdk":"sdk"}))),r={type:"PublishEvent",id:G(this.nextReqId++),sessionId:this.session.id,event:e,data:i,callWebhook:s};return this.setOnceLinked(async()=>{const a=await this.makeRequest(r);if(a.type==="Fail")throw new Error(a.error||"failed to publish event");return a.eventId})}sendData(e){this.ws.sendData(JSON.stringify(e))}updateLastHeartbeat(){this.lastHeartbeatResponse=Date.now()}heartbeat(){if(Date.now()-this.lastHeartbeatResponse>Qe*2){this.ws.disconnect();return}try{this.ws.sendData("h")}catch{}}async makeRequest(e,n={timeout:fn}){const s=e.id;this.sendData(e);let i;return Promise.race([new Promise((r,a)=>{i=window.setTimeout(()=>{a(new Error(`request ${s} timed out`))},n.timeout)}),new Promise(r=>{this.requestResolutions.set(s,a=>{clearTimeout(i),r(a),this.requestResolutions.delete(s)})})])}async handleConnected(){return(await this.makeRequest({type:"HostSession",id:G(this.nextReqId++),sessionId:this.session.id,sessionKey:this.session.key})).type==="Fail"?!1:(this.sendData({type:"IsLinked",id:G(this.nextReqId++),sessionId:this.session.id}),this.sendData({type:"GetSessionConfig",id:G(this.nextReqId++),sessionId:this.session.id}),!0)}}class gn{constructor(){this._nextRequestId=0,this.callbacks=new Map}makeRequestId(){this._nextRequestId=(this._nextRequestId+1)%2147483647;const e=this._nextRequestId,n=gt(e.toString(16));return this.callbacks.get(n)&&this.callbacks.delete(n),e}}/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function yn(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function pe(t,...e){if(!yn(t))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(t.length))throw new Error("Uint8Array expected of length "+e+", got length="+t.length)}function Ze(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function wn(t,e){pe(t);const n=e.outputLen;if(t.length<n)throw new Error("digestInto() expects output buffer of length at least "+n)}function Pe(...t){for(let e=0;e<t.length;e++)t[e].fill(0)}function Ie(t){return new DataView(t.buffer,t.byteOffset,t.byteLength)}function F(t,e){return t<<32-e|t>>>e}const mn=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",bn=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function vn(t){if(pe(t),mn)return t.toHex();let e="";for(let n=0;n<t.length;n++)e+=bn[t[n]];return e}function En(t){if(typeof t!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(t))}function Et(t){return typeof t=="string"&&(t=En(t)),pe(t),t}class _n{}function In(t){const e=s=>t().update(Et(s)).digest(),n=t();return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=()=>t(),e}function Sn(t,e,n,s){if(typeof t.setBigUint64=="function")return t.setBigUint64(e,n,s);const i=BigInt(32),r=BigInt(4294967295),a=Number(n>>i&r),o=Number(n&r),h=s?4:0,f=s?0:4;t.setUint32(e+h,a,s),t.setUint32(e+f,o,s)}function kn(t,e,n){return t&e^~t&n}function An(t,e,n){return t&e^t&n^e&n}class Cn extends _n{constructor(e,n,s,i){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=e,this.outputLen=n,this.padOffset=s,this.isLE=i,this.buffer=new Uint8Array(e),this.view=Ie(this.buffer)}update(e){Ze(this),e=Et(e),pe(e);const{view:n,buffer:s,blockLen:i}=this,r=e.length;for(let a=0;a<r;){const o=Math.min(i-this.pos,r-a);if(o===i){const h=Ie(e);for(;i<=r-a;a+=i)this.process(h,a);continue}s.set(e.subarray(a,a+o),this.pos),this.pos+=o,a+=o,this.pos===i&&(this.process(n,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){Ze(this),wn(e,this),this.finished=!0;const{buffer:n,view:s,blockLen:i,isLE:r}=this;let{pos:a}=this;n[a++]=128,Pe(this.buffer.subarray(a)),this.padOffset>i-a&&(this.process(s,0),a=0);for(let g=a;g<i;g++)n[g]=0;Sn(s,i-8,BigInt(this.length*8),r),this.process(s,0);const o=Ie(e),h=this.outputLen;if(h%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const f=h/4,b=this.get();if(f>b.length)throw new Error("_sha2: outputLen bigger than state");for(let g=0;g<f;g++)o.setUint32(4*g,b[g],r)}digest(){const{buffer:e,outputLen:n}=this;this.digestInto(e);const s=e.slice(0,n);return this.destroy(),s}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:n,buffer:s,length:i,finished:r,destroyed:a,pos:o}=this;return e.destroyed=a,e.finished=r,e.length=i,e.pos=o,i%n&&e.buffer.set(s),e}clone(){return this._cloneInto()}}const Y=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Pn=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),X=new Uint32Array(64);class Rn extends Cn{constructor(e=32){super(64,e,8,!1),this.A=Y[0]|0,this.B=Y[1]|0,this.C=Y[2]|0,this.D=Y[3]|0,this.E=Y[4]|0,this.F=Y[5]|0,this.G=Y[6]|0,this.H=Y[7]|0}get(){const{A:e,B:n,C:s,D:i,E:r,F:a,G:o,H:h}=this;return[e,n,s,i,r,a,o,h]}set(e,n,s,i,r,a,o,h){this.A=e|0,this.B=n|0,this.C=s|0,this.D=i|0,this.E=r|0,this.F=a|0,this.G=o|0,this.H=h|0}process(e,n){for(let g=0;g<16;g++,n+=4)X[g]=e.getUint32(n,!1);for(let g=16;g<64;g++){const u=X[g-15],c=X[g-2],l=F(u,7)^F(u,18)^u>>>3,S=F(c,17)^F(c,19)^c>>>10;X[g]=S+X[g-7]+l+X[g-16]|0}let{A:s,B:i,C:r,D:a,E:o,F:h,G:f,H:b}=this;for(let g=0;g<64;g++){const u=F(o,6)^F(o,11)^F(o,25),c=b+u+kn(o,h,f)+Pn[g]+X[g]|0,S=(F(s,2)^F(s,13)^F(s,22))+An(s,i,r)|0;b=f,f=h,h=o,o=a+c|0,a=r,r=i,i=s,s=c+S|0}s=s+this.A|0,i=i+this.B|0,r=r+this.C|0,a=a+this.D|0,o=o+this.E|0,h=h+this.F|0,f=f+this.G|0,b=b+this.H|0,this.set(s,i,r,a,o,h,f,b)}roundClean(){Pe(X)}destroy(){this.set(0,0,0,0,0,0,0,0),Pe(this.buffer)}}const xn=In(()=>new Rn),Un=xn,et="session:id",tt="session:secret",nt="session:linked";class ie{constructor(e,n,s,i=!1){this.storage=e,this.id=n,this.secret=s,this.key=vn(Un(`${n}, ${s} WalletLink`)),this._linked=!!i}static create(e){const n=ee(16),s=ee(32);return new ie(e,n,s).save()}static load(e){const n=e.getItem(et),s=e.getItem(nt),i=e.getItem(tt);return n&&i?new ie(e,n,i,s==="1"):null}get linked(){return this._linked}set linked(e){this._linked=e,this.persistLinked()}save(){return this.storage.setItem(et,this.id),this.storage.setItem(tt,this.secret),this.persistLinked(),this}persistLinked(){this.storage.setItem(nt,this._linked?"1":"0")}}class z{constructor(e){this.chainCallbackParams={chainId:"",jsonRpcUrl:""},this.isMobileWeb=Rt(),this.linkedUpdated=r=>{this.isLinked=r;const a=this.storage.getItem(Ce);if(r&&(this._session.linked=r),this.isUnlinkedErrorState=!1,a){const o=a.split(" "),h=this.storage.getItem("IsStandaloneSigning")==="true";o[0]!==""&&!r&&this._session.linked&&!h&&(this.isUnlinkedErrorState=!0)}},this.metadataUpdated=(r,a)=>{this.storage.setItem(r,a)},this.chainUpdated=(r,a)=>{this.chainCallbackParams.chainId===r&&this.chainCallbackParams.jsonRpcUrl===a||(this.chainCallbackParams={chainId:r,jsonRpcUrl:a},this.chainCallback&&this.chainCallback(a,Number.parseInt(r,10)))},this.accountUpdated=r=>{this.accountsCallback&&this.accountsCallback([r]),z.accountRequestCallbackIds.size>0&&(Array.from(z.accountRequestCallbackIds.values()).forEach(a=>{this.invokeCallback(a,{method:"requestEthereumAccounts",result:[r]})}),z.accountRequestCallbackIds.clear())},this.resetAndReload=this.resetAndReload.bind(this),this.linkAPIUrl=e.linkAPIUrl,this.storage=e.storage,this.metadata=e.metadata,this.accountsCallback=e.accountsCallback,this.chainCallback=e.chainCallback;const{session:n,ui:s,connection:i}=this.subscribe();this._session=n,this.connection=i,this.relayEventManager=new gn,this.ui=s,this.ui.attach()}subscribe(){const e=ie.load(this.storage)||ie.create(this.storage),{linkAPIUrl:n}=this,s=new pn({session:e,linkAPIUrl:n,listener:this}),i=this.isMobileWeb?new De:new xt;return s.connect(),{session:e,ui:i,connection:s}}resetAndReload(){this.connection.destroy().then(()=>{const e=ie.load(this.storage);(e==null?void 0:e.id)===this._session.id&&$.clearAll(),document.location.reload()}).catch(e=>{})}signEthereumTransaction(e){return this.sendRequest({method:"signEthereumTransaction",params:{fromAddress:e.fromAddress,toAddress:e.toAddress,weiValue:j(e.weiValue),data:oe(e.data,!0),nonce:e.nonce,gasPriceInWei:e.gasPriceInWei?j(e.gasPriceInWei):null,maxFeePerGas:e.gasPriceInWei?j(e.gasPriceInWei):null,maxPriorityFeePerGas:e.gasPriceInWei?j(e.gasPriceInWei):null,gasLimit:e.gasLimit?j(e.gasLimit):null,chainId:e.chainId,shouldSubmit:!1}})}signAndSubmitEthereumTransaction(e){return this.sendRequest({method:"signEthereumTransaction",params:{fromAddress:e.fromAddress,toAddress:e.toAddress,weiValue:j(e.weiValue),data:oe(e.data,!0),nonce:e.nonce,gasPriceInWei:e.gasPriceInWei?j(e.gasPriceInWei):null,maxFeePerGas:e.maxFeePerGas?j(e.maxFeePerGas):null,maxPriorityFeePerGas:e.maxPriorityFeePerGas?j(e.maxPriorityFeePerGas):null,gasLimit:e.gasLimit?j(e.gasLimit):null,chainId:e.chainId,shouldSubmit:!0}})}submitEthereumTransaction(e,n){return this.sendRequest({method:"submitEthereumTransaction",params:{signedTransaction:oe(e,!0),chainId:n}})}getWalletLinkSession(){return this._session}sendRequest(e){let n=null;const s=ee(8),i=r=>{this.publishWeb3RequestCanceledEvent(s),this.handleErrorResponse(s,e.method,r),n==null||n()};return new Promise((r,a)=>{n=this.ui.showConnecting({isUnlinkedErrorState:this.isUnlinkedErrorState,onCancel:i,onResetConnection:this.resetAndReload}),this.relayEventManager.callbacks.set(s,o=>{if(n==null||n(),K(o))return a(new Error(o.errorMessage));r(o)}),this.publishWeb3RequestEvent(s,e)})}publishWeb3RequestEvent(e,n){const s={type:"WEB3_REQUEST",id:e,request:n};this.publishEvent("Web3Request",s,!0).then(i=>{}).catch(i=>{this.handleWeb3ResponseMessage(s.id,{method:n.method,errorMessage:i.message})}),this.isMobileWeb&&this.openCoinbaseWalletDeeplink(n.method)}openCoinbaseWalletDeeplink(e){if(this.ui instanceof De)switch(e){case"requestEthereumAccounts":case"switchEthereumChain":return;default:window.addEventListener("blur",()=>{window.addEventListener("focus",()=>{this.connection.checkUnseenEvents()},{once:!0})},{once:!0}),this.ui.openCoinbaseWalletDeeplink();break}}publishWeb3RequestCanceledEvent(e){const n={type:"WEB3_REQUEST_CANCELED",id:e};this.publishEvent("Web3RequestCanceled",n,!1).then()}publishEvent(e,n,s){return this.connection.publishEvent(e,n,s)}handleWeb3ResponseMessage(e,n){if(n.method==="requestEthereumAccounts"){z.accountRequestCallbackIds.forEach(s=>this.invokeCallback(s,n)),z.accountRequestCallbackIds.clear();return}this.invokeCallback(e,n)}handleErrorResponse(e,n,s){var i;const r=(i=s==null?void 0:s.message)!==null&&i!==void 0?i:"Unspecified error message.";this.handleWeb3ResponseMessage(e,{method:n,errorMessage:r})}invokeCallback(e,n){const s=this.relayEventManager.callbacks.get(e);s&&(s(n),this.relayEventManager.callbacks.delete(e))}requestEthereumAccounts(){const{appName:e,appLogoUrl:n}=this.metadata,s={method:"requestEthereumAccounts",params:{appName:e,appLogoUrl:n}},i=ee(8);return new Promise((r,a)=>{this.relayEventManager.callbacks.set(i,o=>{if(K(o))return a(new Error(o.errorMessage));r(o)}),z.accountRequestCallbackIds.add(i),this.publishWeb3RequestEvent(i,s)})}watchAsset(e,n,s,i,r,a){const o={method:"watchAsset",params:{type:e,options:{address:n,symbol:s,decimals:i,image:r},chainId:a}};let h=null;const f=ee(8),b=g=>{this.publishWeb3RequestCanceledEvent(f),this.handleErrorResponse(f,o.method,g),h==null||h()};return h=this.ui.showConnecting({isUnlinkedErrorState:this.isUnlinkedErrorState,onCancel:b,onResetConnection:this.resetAndReload}),new Promise((g,u)=>{this.relayEventManager.callbacks.set(f,c=>{if(h==null||h(),K(c))return u(new Error(c.errorMessage));g(c)}),this.publishWeb3RequestEvent(f,o)})}addEthereumChain(e,n,s,i,r,a){const o={method:"addEthereumChain",params:{chainId:e,rpcUrls:n,blockExplorerUrls:i,chainName:r,iconUrls:s,nativeCurrency:a}};let h=null;const f=ee(8),b=g=>{this.publishWeb3RequestCanceledEvent(f),this.handleErrorResponse(f,o.method,g),h==null||h()};return h=this.ui.showConnecting({isUnlinkedErrorState:this.isUnlinkedErrorState,onCancel:b,onResetConnection:this.resetAndReload}),new Promise((g,u)=>{this.relayEventManager.callbacks.set(f,c=>{if(h==null||h(),K(c))return u(new Error(c.errorMessage));g(c)}),this.publishWeb3RequestEvent(f,o)})}switchEthereumChain(e,n){const s={method:"switchEthereumChain",params:Object.assign({chainId:e},{address:n})};let i=null;const r=ee(8),a=o=>{this.publishWeb3RequestCanceledEvent(r),this.handleErrorResponse(r,s.method,o),i==null||i()};return i=this.ui.showConnecting({isUnlinkedErrorState:this.isUnlinkedErrorState,onCancel:a,onResetConnection:this.resetAndReload}),new Promise((o,h)=>{this.relayEventManager.callbacks.set(r,f=>{if(i==null||i(),K(f)&&f.errorCode)return h(A.provider.custom({code:f.errorCode,message:"Unrecognized chain ID. Try adding the chain using addEthereumChain first."}));if(K(f))return h(new Error(f.errorMessage));o(f)}),this.publishWeb3RequestEvent(r,s)})}}z.accountRequestCallbackIds=new Set;const st="DefaultChainId",it="DefaultJsonRpcUrl";class _t{constructor(e){this._relay=null,this._addresses=[],this.metadata=e.metadata,this._storage=new $("walletlink",qe),this.callback=e.callback||null;const n=this._storage.getItem(Ce);if(n){const s=n.split(" ");s[0]!==""&&(this._addresses=s.map(i=>J(i)))}this.initializeRelay()}getSession(){const e=this.initializeRelay(),{id:n,secret:s}=e.getWalletLinkSession();return{id:n,secret:s}}async handshake(){await this._eth_requestAccounts()}get selectedAddress(){return this._addresses[0]||void 0}get jsonRpcUrl(){var e;return(e=this._storage.getItem(it))!==null&&e!==void 0?e:void 0}set jsonRpcUrl(e){this._storage.setItem(it,e)}updateProviderInfo(e,n){var s;this.jsonRpcUrl=e;const i=this.getChainId();this._storage.setItem(st,n.toString(10)),ce(n)!==i&&((s=this.callback)===null||s===void 0||s.call(this,"chainChanged",Q(n)))}async watchAsset(e){const n=Array.isArray(e)?e[0]:e;if(!n.type)throw A.rpc.invalidParams("Type is required");if((n==null?void 0:n.type)!=="ERC20")throw A.rpc.invalidParams(`Asset of type '${n.type}' is not supported`);if(!(n!=null&&n.options))throw A.rpc.invalidParams("Options are required");if(!(n!=null&&n.options.address))throw A.rpc.invalidParams("Address is required");const s=this.getChainId(),{address:i,symbol:r,image:a,decimals:o}=n.options,f=await this.initializeRelay().watchAsset(n.type,i,r,o,a,s==null?void 0:s.toString());return K(f)?!1:!!f.result}async addEthereumChain(e){var n,s;const i=e[0];if(((n=i.rpcUrls)===null||n===void 0?void 0:n.length)===0)throw A.rpc.invalidParams("please pass in at least 1 rpcUrl");if(!i.chainName||i.chainName.trim()==="")throw A.rpc.invalidParams("chainName is a required field");if(!i.nativeCurrency)throw A.rpc.invalidParams("nativeCurrency is a required field");const r=Number.parseInt(i.chainId,16);if(r===this.getChainId())return!1;const a=this.initializeRelay(),{rpcUrls:o=[],blockExplorerUrls:h=[],chainName:f,iconUrls:b=[],nativeCurrency:g}=i,u=await a.addEthereumChain(r.toString(),o,b,h,f,g);if(K(u))return!1;if(((s=u.result)===null||s===void 0?void 0:s.isApproved)===!0)return this.updateProviderInfo(o[0],r),null;throw A.rpc.internal("unable to add ethereum chain")}async switchEthereumChain(e){const n=e[0],s=Number.parseInt(n.chainId,16),r=await this.initializeRelay().switchEthereumChain(s.toString(10),this.selectedAddress||void 0);if(K(r))throw r;const a=r.result;return a.isApproved&&a.rpcUrl.length>0&&this.updateProviderInfo(a.rpcUrl,s),null}async cleanup(){this.callback=null,this._relay&&this._relay.resetAndReload(),this._storage.clear()}_setAddresses(e,n){var s;if(!Array.isArray(e))throw new Error("addresses is not an array");const i=e.map(r=>J(r));JSON.stringify(i)!==JSON.stringify(this._addresses)&&(this._addresses=i,(s=this.callback)===null||s===void 0||s.call(this,"accountsChanged",i),this._storage.setItem(Ce,i.join(" ")))}async request(e){const n=e.params||[];switch(e.method){case"eth_accounts":return[...this._addresses];case"eth_coinbase":return this.selectedAddress||null;case"net_version":return this.getChainId().toString(10);case"eth_chainId":return Q(this.getChainId());case"eth_requestAccounts":return this._eth_requestAccounts();case"eth_ecRecover":case"personal_ecRecover":return this.ecRecover(e);case"personal_sign":return this.personalSign(e);case"eth_signTransaction":return this._eth_signTransaction(n);case"eth_sendRawTransaction":return this._eth_sendRawTransaction(n);case"eth_sendTransaction":return this._eth_sendTransaction(n);case"eth_signTypedData_v1":case"eth_signTypedData_v3":case"eth_signTypedData_v4":case"eth_signTypedData":return this.signTypedData(e);case"wallet_addEthereumChain":return this.addEthereumChain(n);case"wallet_switchEthereumChain":return this.switchEthereumChain(n);case"wallet_watchAsset":return this.watchAsset(n);default:if(!this.jsonRpcUrl)throw A.rpc.internal("No RPC URL set for chain");return Oe(e,this.jsonRpcUrl)}}_ensureKnownAddress(e){const n=J(e);if(!this._addresses.map(i=>J(i)).includes(n))throw new Error("Unknown Ethereum address")}_prepareTransactionParams(e){const n=e.from?J(e.from):this.selectedAddress;if(!n)throw new Error("Ethereum address is unavailable");this._ensureKnownAddress(n);const s=e.to?J(e.to):null,i=e.value!=null?re(e.value):BigInt(0),r=e.data?Ae(e.data):Buffer.alloc(0),a=e.nonce!=null?ce(e.nonce):null,o=e.gasPrice!=null?re(e.gasPrice):null,h=e.maxFeePerGas!=null?re(e.maxFeePerGas):null,f=e.maxPriorityFeePerGas!=null?re(e.maxPriorityFeePerGas):null,b=e.gas!=null?re(e.gas):null,g=e.chainId?ce(e.chainId):this.getChainId();return{fromAddress:n,toAddress:s,weiValue:i,data:r,nonce:a,gasPriceInWei:o,maxFeePerGas:h,maxPriorityFeePerGas:f,gasLimit:b,chainId:g}}async ecRecover(e){const{method:n,params:s}=e;if(!Array.isArray(s))throw A.rpc.invalidParams();const r=await this.initializeRelay().sendRequest({method:"ethereumAddressFromSignedMessage",params:{message:ge(s[0]),signature:ge(s[1]),addPrefix:n==="personal_ecRecover"}});if(K(r))throw r;return r.result}getChainId(){var e;return Number.parseInt((e=this._storage.getItem(st))!==null&&e!==void 0?e:"1",10)}async _eth_requestAccounts(){var e,n;if(this._addresses.length>0)return(e=this.callback)===null||e===void 0||e.call(this,"connect",{chainId:Q(this.getChainId())}),this._addresses;const i=await this.initializeRelay().requestEthereumAccounts();if(K(i))throw i;if(!i.result)throw new Error("accounts received is empty");return this._setAddresses(i.result),(n=this.callback)===null||n===void 0||n.call(this,"connect",{chainId:Q(this.getChainId())}),this._addresses}async personalSign({params:e}){if(!Array.isArray(e))throw A.rpc.invalidParams();const n=e[1],s=e[0];this._ensureKnownAddress(n);const r=await this.initializeRelay().sendRequest({method:"signEthereumMessage",params:{address:J(n),message:ge(s),addPrefix:!0,typedDataJson:null}});if(K(r))throw r;return r.result}async _eth_signTransaction(e){const n=this._prepareTransactionParams(e[0]||{}),i=await this.initializeRelay().signEthereumTransaction(n);if(K(i))throw i;return i.result}async _eth_sendRawTransaction(e){const n=Ae(e[0]),i=await this.initializeRelay().submitEthereumTransaction(n,this.getChainId());if(K(i))throw i;return i.result}async _eth_sendTransaction(e){const n=this._prepareTransactionParams(e[0]||{}),i=await this.initializeRelay().signAndSubmitEthereumTransaction(n);if(K(i))throw i;return i.result}async signTypedData(e){const{method:n,params:s}=e;if(!Array.isArray(s))throw A.rpc.invalidParams();const i=f=>{const b={eth_signTypedData_v1:he.hashForSignTypedDataLegacy,eth_signTypedData_v3:he.hashForSignTypedData_v3,eth_signTypedData_v4:he.hashForSignTypedData_v4,eth_signTypedData:he.hashForSignTypedData_v4};return oe(b[n]({data:Kt(f)}),!0)},r=s[n==="eth_signTypedData_v1"?1:0],a=s[n==="eth_signTypedData_v1"?0:1];this._ensureKnownAddress(r);const h=await this.initializeRelay().sendRequest({method:"signEthereumMessage",params:{address:J(r),message:i(a),typedDataJson:JSON.stringify(a,null,2),addPrefix:!1}});if(K(h))throw h;return h.result}initializeRelay(){return this._relay||(this._relay=new z({linkAPIUrl:qe,storage:this._storage,metadata:this.metadata,accountsCallback:this._setAddresses.bind(this),chainCallback:this.updateProviderInfo.bind(this)})),this._relay}}const It="SignerType",St=new $("CBWSDK","SignerConfigurator");function Tn(){return St.getItem(It)}function Ln(t){St.setItem(It,t)}async function On(t){const{communicator:e,metadata:n,handshakeRequest:s,callback:i}=t;Nn(e,n,i).catch(()=>{});const r={id:crypto.randomUUID(),event:"selectSignerType",data:Object.assign(Object.assign({},t.preference),{handshakeRequest:s})},{data:a}=await e.postRequestAndWaitForResponse(r);return a}function Bn(t){const{signerType:e,metadata:n,communicator:s,callback:i}=t;switch(e){case"scw":return new Zt({metadata:n,callback:i,communicator:s});case"walletlink":return new _t({metadata:n,callback:i})}}async function Nn(t,e,n){await t.onMessage(({event:i})=>i==="WalletLinkSessionRequest");const s=new _t({metadata:e,callback:n});t.postMessage({event:"WalletLinkUpdate",data:{session:s.getSession()}}),await s.handshake(),t.postMessage({event:"WalletLinkUpdate",data:{connected:!0}})}const Dn=`Coinbase Wallet SDK requires the Cross-Origin-Opener-Policy header to not be set to 'same-origin'. This is to ensure that the SDK can communicate with the Coinbase Smart Wallet app.

Please see https://www.smartwallet.dev/guides/tips/popup-tips#cross-origin-opener-policy for more information.`,qn=()=>{let t;return{getCrossOriginOpenerPolicy:()=>t===void 0?"undefined":t,checkCrossOriginOpenerPolicy:async()=>{if(typeof window>"u"){t="non-browser-env";return}try{const e=`${window.location.origin}${window.location.pathname}`,n=await fetch(e,{method:"HEAD"});if(!n.ok)throw new Error(`HTTP error! status: ${n.status}`);const s=n.headers.get("Cross-Origin-Opener-Policy");t=s??"null",t==="same-origin"&&console.error(Dn)}catch(e){console.error("Error checking Cross-Origin-Opener-Policy:",e.message),t="error"}}}},{checkCrossOriginOpenerPolicy:Hn,getCrossOriginOpenerPolicy:Kn}=qn(),rt=420,at=540;function Wn(t){const e=(window.innerWidth-rt)/2+window.screenX,n=(window.innerHeight-at)/2+window.screenY;jn(t);const s=`wallet_${crypto.randomUUID()}`,i=window.open(t,s,`width=${rt}, height=${at}, left=${e}, top=${n}`);if(i==null||i.focus(),!i)throw A.rpc.internal("Pop up window failed to open");return i}function Mn(t){t&&!t.closed&&t.close()}function jn(t){const e={sdkName:bt,sdkVersion:ue,origin:window.location.origin,coop:Kn()};for(const[n,s]of Object.entries(e))t.searchParams.append(n,s.toString())}class Fn{constructor({url:e=Ut,metadata:n,preference:s}){this.popup=null,this.listeners=new Map,this.postMessage=async i=>{(await this.waitForPopupLoaded()).postMessage(i,this.url.origin)},this.postRequestAndWaitForResponse=async i=>{const r=this.onMessage(({requestId:a})=>a===i.id);return this.postMessage(i),await r},this.onMessage=async i=>new Promise((r,a)=>{const o=h=>{if(h.origin!==this.url.origin)return;const f=h.data;i(f)&&(r(f),window.removeEventListener("message",o),this.listeners.delete(o))};window.addEventListener("message",o),this.listeners.set(o,{reject:a})}),this.disconnect=()=>{Mn(this.popup),this.popup=null,this.listeners.forEach(({reject:i},r)=>{i(A.provider.userRejectedRequest("Request rejected")),window.removeEventListener("message",r)}),this.listeners.clear()},this.waitForPopupLoaded=async()=>this.popup&&!this.popup.closed?(this.popup.focus(),this.popup):(this.popup=Wn(this.url),this.onMessage(({event:i})=>i==="PopupUnload").then(this.disconnect).catch(()=>{}),this.onMessage(({event:i})=>i==="PopupLoaded").then(i=>{this.postMessage({requestId:i.id,data:{version:ue,metadata:this.metadata,preference:this.preference,location:window.location.toString()}})}).then(()=>{if(!this.popup)throw A.rpc.internal();return this.popup})),this.url=new URL(e),this.metadata=n,this.preference=s}}function $n(t){const e=Bt(Gn(t),{shouldIncludeStack:!0}),n=new URL("https://docs.cloud.coinbase.com/wallet-sdk/docs/errors");return n.searchParams.set("version",ue),n.searchParams.set("code",e.code.toString()),n.searchParams.set("message",e.message),Object.assign(Object.assign({},e),{docUrl:n.href})}function Gn(t){var e;if(typeof t=="string")return{message:t,code:N.rpc.internal};if(K(t)){const n=t.errorMessage,s=(e=t.errorCode)!==null&&e!==void 0?e:n.match(/(denied|rejected)/i)?N.provider.userRejectedRequest:void 0;return Object.assign(Object.assign({},t),{message:n,code:s,data:{method:t.method}})}return t}class zn extends Pt{}var Vn=function(t,e){var n={};for(var s in t)Object.prototype.hasOwnProperty.call(t,s)&&e.indexOf(s)<0&&(n[s]=t[s]);if(t!=null&&typeof Object.getOwnPropertySymbols=="function")for(var i=0,s=Object.getOwnPropertySymbols(t);i<s.length;i++)e.indexOf(s[i])<0&&Object.prototype.propertyIsEnumerable.call(t,s[i])&&(n[s[i]]=t[s[i]]);return n};class Jn extends zn{constructor(e){var{metadata:n}=e,s=e.preference,{keysUrl:i}=s,r=Vn(s,["keysUrl"]);super(),this.signer=null,this.isCoinbaseWallet=!0,this.metadata=n,this.preference=r,this.communicator=new Fn({url:i,metadata:n,preference:r});const a=Tn();a&&(this.signer=this.initSigner(a))}async request(e){try{if(Qt(e),!this.signer)switch(e.method){case"eth_requestAccounts":{const n=await this.requestSignerSelection(e),s=this.initSigner(n);await s.handshake(e),this.signer=s,Ln(n);break}case"wallet_sendCalls":{const n=this.initSigner("scw");await n.handshake({method:"handshake"});const s=await n.request(e);return await n.cleanup(),s}case"wallet_getCallsStatus":return Oe(e,Tt);case"net_version":return 1;case"eth_chainId":return Q(1);default:throw A.provider.unauthorized("Must call 'eth_requestAccounts' before other methods")}return await this.signer.request(e)}catch(n){const{code:s}=n;return s===N.provider.unauthorized&&this.disconnect(),Promise.reject($n(n))}}async enable(){return console.warn('.enable() has been deprecated. Please use .request({ method: "eth_requestAccounts" }) instead.'),await this.request({method:"eth_requestAccounts"})}async disconnect(){var e;await((e=this.signer)===null||e===void 0?void 0:e.cleanup()),this.signer=null,$.clearAll(),this.emit("disconnect",A.provider.disconnected("User initiated disconnection"))}requestSignerSelection(e){return On({communicator:this.communicator,preference:this.preference,metadata:this.metadata,handshakeRequest:e,callback:this.emit.bind(this)})}initSigner(e){return Bn({signerType:e,metadata:this.metadata,communicator:this.communicator,callback:this.emit.bind(this)})}}function Yn(t){if(t){if(!["all","smartWalletOnly","eoaOnly"].includes(t.options))throw new Error(`Invalid options: ${t.options}`);if(t.attribution&&t.attribution.auto!==void 0&&t.attribution.dataSuffix!==void 0)throw new Error("Attribution cannot contain both auto and dataSuffix properties")}}function Xn(t){var e;const n={metadata:t.metadata,preference:t.preference};return(e=Xt(n))!==null&&e!==void 0?e:new Jn(n)}const Qn={options:"all"};function rs(t){var e;new $("CBWSDK").setItem("VERSION",ue),Hn();const s={metadata:{appName:t.appName||"Dapp",appLogoUrl:t.appLogoUrl||"",appChainIds:t.appChainIds||[]},preference:Object.assign(Qn,(e=t.preference)!==null&&e!==void 0?e:{})};Yn(s.preference);let i=null;return{getProvider:()=>(i||(i=Xn(s)),i)}}export{rs as createCoinbaseWalletSDK};
